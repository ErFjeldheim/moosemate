
# Git

Git makes development smoother and more sustainable by cutting down on redundant work and making collaboration easier. Its distributed setup means developers can work offline, which reduces server load and network traffic. Team members can tackle different features at the same time without stepping on each other’s toes, so there’s less wasted time dealing with merge conflicts or lost code.

Git’s branching system also makes it easy to experiment safely. Developers can test new ideas locally before committing changes, catching problems early instead of scrambling to fix them later in production. And if something does go wrong, the full project history makes it simple to roll back to a previous version and move on quickly. Thus saving time and resources for us as developers. 

By keeping detailed records of every change, Git helps teams avoid duplicate work and unnecessary rework. That means less time spent resolving issues and more time building features. It also makes development more efficient overall—saving both time and computing resources in the process.

---

# Multi-Modularity

A multi-modular architecture using separate modules for UI, Core, Persistence, and REST provides a sustainable and efficient structure. It supports cleaner code organization, better maintainability, and enhanced scalability.

- Running individual modules consumes less energy than executing the entire system each time.  
- Teams can work on separate modules without affecting the whole project, reducing development time and resource waste.  
- Limited technical depth keeps refactoring efforts contained within each module, improving maintainability and reducing costs.

This modular approach also improves adaptability. When technologies evolve, individual modules can be upgraded or replaced without a full rewrite, reducing redundancy and extending the system’s lifecycle. Each module can be tested and deployed independently, improving quality control and minimizing cascading errors. Over time, this approach reduces workload, rework cycles, and the app’s overall computational footprint.

---

# Testing

Extensive test coverage prevents costly hotfixes and emergency deployments, saving developer time and reducing rollbacks and redeployments. Automated testing ensures that potential issues are caught early, before reaching production environments. By identifying bugs sooner, MooseMate minimizes unnecessary builds, redeployments, and server activity.

Testing supports long-term software health by enabling continuous integration and deployment pipelines that run efficiently. Stable, predictable software requires fewer interventions and consumes fewer computing resources.  
In this way, testing becomes a key aspect of sustainability — conserving both human effort and digital energy, and ensuring that MooseMate remains reliable, maintainable, and sustainable over time.

---

# Development Project Context

MooseMate is a development project created for learning purposes, not meant to be launched or hosted publicly. This means there's minimal energy consumption beyond the development phase itself. While sustainability is still worth thinking about and practicing, it's naturally less critical in academic projects like this compared to real-world applications that run 24/7. These principles matter most when building actual production systems that need continuous hosting and maintenance.

---

# UN Sustainability Development Goals (SDG)

MooseMate touches on a few UN Sustainable Development Goals through how we built it. Our modular architecture and automated testing connect to SDG 12 (Responsible Consumption) by reducing wasted work and rework. While this is just a university project, these practices set us up to build genuinely sustainable software down the line.
